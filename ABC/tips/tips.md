区間の和と言われたら、累積和を使うと良い場合が多い

# CheckList
1: i, jの書き違い (例: for(int i = 0; i < n; i++) for(int j = 0; j < m; i++) )
2: 問題文の読み違え
3: 変数名の重複
4: 提出するコードを間違える
5: 初期化忘れ
6: 計算量の見誤り
7: builtin関数の未定義動作 (例: __builtin_ctz(0) )
8: 二分探索の最大値・最小値の見誤り
9: forの++,--を逆にする (例: for(int i = n - 1; i >= 0; i++) )
10: long longなのにint用の関数を使う
11: オーバーフロー
12: 配列のサイズ不足
13: free!
14: set, mapが遅くてTLE
15: 剰余を取るのを忘れる
16: コーナーケース
17: n = 0のときを忘れる
18: 0除算
19: メモ化できていない
20: 嘘の貪欲解法
21: 出力する文字列のスペルミス
22: 浮動小数点の誤差
23: 負の数の剰余の扱い (例: 間違い: a = (b - c) % MOD, 正解: a = (b - c + MOD) % MOD)
24: 入力をcinで取ってTLE
25: 配列外参照

### 茶色になるまで
Aはシミュレーションであったり、if文か文字列や数値を上手く入れ替えたり変換できるか
Bは全探索がメインで出来るかどうか
[すごいぞitertoolsくん](https://qiita.com/anmint/items/37ca0ded5e1d360b51f3)を使えば大体できる
累積和とランレングス圧縮としてPythonのitertoolsのGroupByを導入すれば大体出来るようになる

### 緑になるまで